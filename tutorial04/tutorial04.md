# ä»Žé›¶å¼€å§‹çš„ JSON åº“æ•™ç¨‹ï¼ˆå››ï¼‰ï¼šUnicode

* Milo Yip
* 2016/10/2

æœ¬æ–‡æ˜¯[ã€Šä»Žé›¶å¼€å§‹çš„ JSON åº“æ•™ç¨‹ã€‹](https://zhuanlan.zhihu.com/json-tutorial)çš„ç¬¬å››ä¸ªå•å…ƒã€‚ä»£ç ä½äºŽ [json-tutorial/tutorial04](https://github.com/miloyip/json-tutorial/tree/master/tutorial04)ã€‚

æœ¬å•å…ƒå†…å®¹ï¼š

1. [Unicode](#1-unicode)
2. [éœ€æ±‚](#2-éœ€æ±‚)
3. [UTF-8 ç¼–ç ](#3-utf-8-ç¼–ç )
4. [å®žçŽ° `\uXXXX` è§£æž](#4-å®žçŽ°-uxxxx-è§£æž)
5. [æ€»ç»“ä¸Žç»ƒä¹ ](#5-æ€»ç»“ä¸Žç»ƒä¹ )

## 1. Unicode

åœ¨ä¸Šä¸€ä¸ªå•å…ƒï¼Œæˆ‘ä»¬å·²ç»èƒ½è§£æžã€Œä¸€èˆ¬ã€çš„ JSON å­—ç¬¦ä¸²ï¼Œä»…ä»…æ²¡æœ‰å¤„ç† `\uXXXX` è¿™ç§è½¬ä¹‰åºåˆ—ã€‚ä¸ºäº†è§£æžè¿™ç§åºåˆ—ï¼Œæˆ‘ä»¬å¿…é¡»äº†è§£æœ‰å…³ Unicode çš„åŸºæœ¬æ¦‚å¿µã€‚

è¯»è€…åº”è¯¥çŸ¥é“ ASCIIï¼Œå®ƒæ˜¯ä¸€ç§å­—ç¬¦ç¼–ç ï¼ŒæŠŠ 128 ä¸ªå­—ç¬¦æ˜ å°„è‡³æ•´æ•° 0 ~ 127ã€‚ä¾‹å¦‚ï¼Œ`1` â†’ 49ï¼Œ`A` â†’ 65ï¼Œ`B` â†’ 66 ç­‰ç­‰ã€‚è¿™ç§ 7-bit å­—ç¬¦ç¼–ç ç³»ç»Ÿéžå¸¸ç®€å•ï¼Œåœ¨è®¡ç®—æœºä¸­ä»¥ä¸€ä¸ªå­—èŠ‚å­˜å‚¨ä¸€ä¸ªå­—ç¬¦ã€‚ç„¶è€Œï¼Œå®ƒä»…é€‚åˆç¾Žå›½è‹±è¯­ï¼Œç”šè‡³ä¸€äº›è‹±è¯­ä¸­å¸¸ç”¨çš„æ ‡ç‚¹ç¬¦å·ã€é‡éŸ³ç¬¦å·éƒ½ä¸èƒ½è¡¨ç¤ºï¼Œæ— æ³•è¡¨ç¤ºå„å›½è¯­è¨€ï¼Œç‰¹åˆ«æ˜¯ä¸­æ—¥éŸ©è¯­ç­‰è¡¨æ„æ–‡å­—ã€‚

åœ¨ Unicode å‡ºçŽ°ä¹‹å‰ï¼Œå„åœ°åŒºåˆ¶å®šäº†ä¸åŒçš„ç¼–ç ç³»ç»Ÿï¼Œå¦‚ä¸­æ–‡ä¸»è¦ç”¨ GB 2312 å’Œå¤§äº”ç ã€æ—¥æ–‡ä¸»è¦ç”¨ JIS ç­‰ã€‚è¿™æ ·ä¼šé€ æˆå¾ˆå¤šä¸ä¾¿ï¼Œä¾‹å¦‚ä¸€ä¸ªæ–‡æœ¬ä¿¡æ¯å¾ˆéš¾æ··åˆå„ç§è¯­è¨€çš„æ–‡å­—ã€‚

å› æ­¤ï¼Œåœ¨ä¸Šä¸–çºª80å¹´ä»£æœ«ï¼ŒXeroxã€Apple ç­‰å…¬å¸å¼€å§‹ç ”ç©¶ï¼Œæ˜¯å¦èƒ½åˆ¶å®šä¸€å¥—å¤šè¯­è¨€çš„ç»Ÿä¸€ç¼–ç ç³»ç»Ÿã€‚åŽæ¥ï¼Œå¤šä¸ªæœºæž„æˆç«‹äº† Unicode è”ç›Ÿï¼Œåœ¨ 1991 å¹´é‡Šå‡º Unicode 1.0ï¼Œæ”¶å½•äº† 24 ç§è¯­è¨€å…± 7161 ä¸ªå­—ç¬¦ã€‚åœ¨å››åˆ†ä¹‹ä¸€ä¸ªä¸–çºªåŽçš„ 2016å¹´ï¼ŒUnicode å·²é‡Šå‡º 9.0 ç‰ˆæœ¬ï¼Œæ”¶å½• 135 ç§è¯­è¨€å…± 128237 ä¸ªå­—ç¬¦ã€‚

è¿™äº›å­—ç¬¦è¢«æ”¶å½•ä¸ºç»Ÿä¸€å­—ç¬¦é›†ï¼ˆUniversal Coded Character Set, UCSï¼‰ï¼Œæ¯ä¸ªå­—ç¬¦æ˜ å°„è‡³ä¸€ä¸ªæ•´æ•°ç ç‚¹ï¼ˆcode pointï¼‰ï¼Œç ç‚¹çš„èŒƒå›´æ˜¯ 0 è‡³ 0x10FFFFï¼Œç ç‚¹åˆé€šå¸¸è®°ä½œ U+XXXXï¼Œå½“ä¸­ XXXX ä¸º 16 è¿›ä½æ•°å­—ã€‚ä¾‹å¦‚ `åŠ²` â†’ U+52B2ã€`å³°` â†’ U+5CF0ã€‚å¾ˆæ˜Žæ˜¾ï¼ŒUCS ä¸­çš„å­—ç¬¦æ— æ³•åƒ ASCII èˆ¬ä»¥ä¸€ä¸ªå­—èŠ‚å­˜å‚¨ã€‚

å› æ­¤ï¼ŒUnicode è¿˜åˆ¶å®šäº†å„ç§å‚¨å­˜ç ç‚¹çš„æ–¹å¼ï¼Œè¿™äº›æ–¹å¼ç§°ä¸º  Unicode è½¬æ¢æ ¼å¼ï¼ˆUniform Transformation Format, UTFï¼‰ã€‚çŽ°æ—¶æµè¡Œçš„ UTF ä¸º UTF-8ã€UTF-16 å’Œ UTF-32ã€‚æ¯ç§ UTF ä¼šæŠŠä¸€ä¸ªç ç‚¹å‚¨å­˜ä¸ºä¸€è‡³å¤šä¸ªç¼–ç å•å…ƒï¼ˆcode unitï¼‰ã€‚ä¾‹å¦‚ UTF-8 çš„ç¼–ç å•å…ƒæ˜¯ 8 ä½çš„å­—èŠ‚ã€UTF-16 ä¸º 16 ä½ã€UTF-32 ä¸º 32 ä½ã€‚é™¤ UTF-32 å¤–ï¼ŒUTF-8 å’Œ UTF-16 éƒ½æ˜¯å¯å˜é•¿åº¦ç¼–ç ã€‚

UTF-8 æˆä¸ºçŽ°æ—¶äº’è”ç½‘ä¸Šæœ€æµè¡Œçš„æ ¼å¼ï¼Œæœ‰å‡ ä¸ªåŽŸå› ï¼š

1. å®ƒé‡‡ç”¨å­—èŠ‚ä¸ºç¼–ç å•å…ƒï¼Œä¸ä¼šæœ‰å­—èŠ‚åºï¼ˆendiannessï¼‰çš„é—®é¢˜ã€‚
2. æ¯ä¸ª ASCII å­—ç¬¦åªéœ€ä¸€ä¸ªå­—èŠ‚åŽ»å‚¨å­˜ã€‚
3. å¦‚æžœç¨‹åºåŽŸæ¥æ˜¯ä»¥å­—èŠ‚æ–¹å¼å‚¨å­˜å­—ç¬¦ï¼Œç†è®ºä¸Šä¸éœ€è¦ç‰¹åˆ«æ”¹åŠ¨å°±èƒ½å¤„ç† UTF-8 çš„æ•°æ®ã€‚

## 2. éœ€æ±‚

ç”±äºŽ UTF-8 çš„æ™®åŠæ€§ï¼Œå¤§éƒ¨åˆ†çš„ JSON ä¹Ÿé€šå¸¸ä¼šä»¥ UTF-8 å­˜å‚¨ã€‚æˆ‘ä»¬çš„ JSON åº“ä¹Ÿä¼šåªæ”¯æŒ UTF-8ã€‚ï¼ˆRapidJSON åŒæ—¶æ”¯æŒ UTF-8ã€UTF-16LE/BEã€UTF-32LE/BEã€ASCIIã€‚ï¼‰

C æ ‡å‡†åº“æ²¡æœ‰å…³äºŽ Unicode çš„å¤„ç†åŠŸèƒ½ï¼ˆC++11 æœ‰ï¼‰ï¼Œæˆ‘ä»¬ä¼šå®žçŽ° JSON åº“æ‰€éœ€çš„å­—ç¬¦ç¼–ç å¤„ç†åŠŸèƒ½ã€‚

å¯¹äºŽéžè½¬ä¹‰ï¼ˆunescapedï¼‰çš„å­—ç¬¦ï¼Œåªè¦å®ƒä»¬ä¸å°‘äºŽ 32ï¼ˆ0 ~ 31 æ˜¯ä¸åˆæ³•çš„ç¼–ç å•å…ƒï¼‰ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æŽ¥å¤åˆ¶è‡³ç»“æžœï¼Œè¿™ä¸€ç‚¹æˆ‘ä»¬ç¨åŽå†è¯´æ˜Žã€‚æˆ‘ä»¬å‡è®¾è¾“å…¥æ˜¯ä»¥åˆæ³• UTF-8 ç¼–ç ã€‚

è€Œå¯¹äºŽ JSONå­—ç¬¦ä¸²ä¸­çš„ `\uXXXX` æ˜¯ä»¥ 16 è¿›åˆ¶è¡¨ç¤ºç ç‚¹ U+0000 è‡³ U+FFFFï¼Œæˆ‘ä»¬éœ€è¦ï¼š

1. è§£æž 4 ä½åå…­è¿›åˆ¶æ•´æ•°ä¸ºç ç‚¹ï¼›
2. ç”±äºŽå­—ç¬¦ä¸²æ˜¯ä»¥ UTF-8 å­˜å‚¨ï¼Œæˆ‘ä»¬è¦æŠŠè¿™ä¸ªç ç‚¹ç¼–ç æˆ UTF-8ã€‚

åŒå­¦å¯èƒ½ä¼šå‘çŽ°ï¼Œ4 ä½çš„ 16 è¿›åˆ¶æ•°å­—åªèƒ½è¡¨ç¤º 0 è‡³ 0xFFFFï¼Œä½†ä¹‹å‰æˆ‘ä»¬è¯´ UCS çš„ç ç‚¹æ˜¯ä»Ž 0 è‡³ 0x10FFFFï¼Œé‚£æ€Žä¹ˆèƒ½è¡¨ç¤ºå¤šå‡ºæ¥çš„ç ç‚¹ï¼Ÿ

å…¶å®žï¼ŒU+0000 è‡³ U+FFFF è¿™ç»„ Unicode å­—ç¬¦ç§°ä¸ºåŸºæœ¬å¤šæ–‡ç§å¹³é¢ï¼ˆbasic multilingual plane, BMPï¼‰ï¼Œè¿˜æœ‰å¦å¤– 16 ä¸ªå¹³é¢ã€‚é‚£ä¹ˆ BMP ä»¥å¤–çš„å­—ç¬¦ï¼ŒJSON ä¼šä½¿ç”¨ä»£ç†å¯¹ï¼ˆsurrogate pairï¼‰è¡¨ç¤º `\uXXXX\uYYYY`ã€‚åœ¨ BMP ä¸­ï¼Œä¿ç•™äº† 2048 ä¸ªä»£ç†ç ç‚¹ã€‚å¦‚æžœç¬¬ä¸€ä¸ªç ç‚¹æ˜¯ U+D800 è‡³ U+DBFFï¼ˆç®—ä¸€ä¸‹ç¡®å®žæ˜¯2^11ï¼‰ï¼Œæˆ‘ä»¬ä¾¿çŸ¥é“å®ƒçš„ä»£ç å¯¹çš„é«˜ä»£ç†é¡¹ï¼ˆhigh surrogateï¼‰ï¼Œä¹‹åŽåº”è¯¥ä¼´éšä¸€ä¸ª U+DC00 è‡³ U+DFFF çš„ä½Žä»£ç†é¡¹ï¼ˆlow surrogateï¼‰ã€‚ç„¶åŽï¼Œæˆ‘ä»¬ç”¨ä¸‹åˆ—å…¬å¼æŠŠä»£ç†å¯¹ (H, L) å˜æ¢æˆçœŸå®žçš„ç ç‚¹ï¼š

~~~
codepoint = 0x10000 + (H âˆ’ 0xD800) Ã— 0x400 + (L âˆ’ 0xDC00)
~~~

ä¸¾ä¸ªä¾‹å­ï¼Œé«˜éŸ³è°±å·å­—ç¬¦ `ð„ž` â†’ U+1D11E ä¸æ˜¯ BMP ä¹‹å†…çš„å­—ç¬¦ã€‚åœ¨ JSON ä¸­å¯å†™æˆè½¬ä¹‰åºåˆ— `\uD834\uDD1E`ï¼Œæˆ‘ä»¬è§£æžç¬¬ä¸€ä¸ª `\uD834` å¾—åˆ°ç ç‚¹ U+D834ï¼Œæˆ‘ä»¬å‘çŽ°å®ƒæ˜¯ U+D800 è‡³ U+DBFF å†…çš„ç ç‚¹ï¼Œæ‰€ä»¥å®ƒæ˜¯é«˜ä»£ç†é¡¹ã€‚ç„¶åŽæˆ‘ä»¬è§£æžä¸‹ä¸€ä¸ªè½¬ä¹‰åºåˆ— `\uDD1E` å¾—åˆ°ç ç‚¹ U+DD1Eï¼Œå®ƒåœ¨ U+DC00 è‡³ U+DFFF ä¹‹å†…ï¼Œæ˜¯åˆæ³•çš„ä½Žä»£ç†é¡¹ã€‚æˆ‘ä»¬è®¡ç®—å…¶ç ç‚¹ï¼š

~~~
H = 0xD834, L = 0xDD1E
codepoint = 0x10000 + (H âˆ’ 0xD800) Ã— 0x400 + (L âˆ’ 0xDC00)
          = 0x10000 + (0xD834 - 0xD800) Ã— 0x400 + (0xDD1E âˆ’ 0xDC00)
          = 0x10000 + 0x34 Ã— 0x400 + 0x11E
          = 0x10000 + 0xD000 + 0x11E
          = 0x1D11E
~~~

è¿™æ ·å°±å¾—å‡ºè¿™è½¬ä¹‰åºåˆ—çš„ç ç‚¹ï¼Œç„¶åŽæˆ‘ä»¬å†æŠŠå®ƒç¼–ç æˆ UTF-8ã€‚å¦‚æžœåªæœ‰é«˜ä»£ç†é¡¹è€Œæ¬ ç¼ºä½Žä»£ç†é¡¹ï¼Œæˆ–æ˜¯ä½Žä»£ç†é¡¹ä¸åœ¨åˆæ³•ç ç‚¹èŒƒå›´ï¼Œæˆ‘ä»¬éƒ½è¿”å›ž `LEPT_PARSE_INVALID_UNICODE_SURROGATE` é”™è¯¯ã€‚å¦‚æžœ `\u` åŽä¸æ˜¯ 4 ä½åå…­è¿›ä½æ•°å­—ï¼Œåˆ™è¿”å›ž `LEPT_PARSE_INVALID_UNICODE_HEX` é”™è¯¯ã€‚

## 3. UTF-8 ç¼–ç 

UTF-8 åœ¨ç½‘é¡µä¸Šçš„ä½¿ç”¨çŽ‡åŠ¿æ— å¯æŒ¡ï¼š

![ ](images/Utf8webgrowth.png)

ï¼ˆå›¾ç‰‡æ¥è‡ª [Wikipedia Common](https://commons.wikimedia.org/wiki/File:Utf8webgrowth.svg)ï¼Œæ•°æ®æ¥è‡ª Google å¯¹ç½‘é¡µå­—ç¬¦ç¼–ç çš„ç»Ÿè®¡ã€‚ï¼‰

ç”±äºŽæˆ‘ä»¬çš„ JSON åº“ä¹Ÿåªæ”¯æŒ UTF-8ï¼Œæˆ‘ä»¬éœ€è¦æŠŠç ç‚¹ç¼–ç æˆ UTF-8ã€‚è¿™é‡Œç®€å•ä»‹ç»ä¸€ä¸‹ UTF-8 çš„ç¼–ç æ–¹å¼ã€‚

UTF-8 çš„ç¼–ç å•å…ƒä¸º 8 ä½ï¼ˆ1 å­—èŠ‚ï¼‰ï¼Œæ¯ä¸ªç ç‚¹ç¼–ç æˆ 1 è‡³ 4 ä¸ªå­—èŠ‚ã€‚å®ƒçš„ç¼–ç æ–¹å¼å¾ˆç®€å•ï¼ŒæŒ‰ç…§ç ç‚¹çš„èŒƒå›´ï¼ŒæŠŠç ç‚¹çš„äºŒè¿›ä½åˆ†æ‹†æˆ 1 è‡³æœ€å¤š 4 ä¸ªå­—èŠ‚ï¼š

| ç ç‚¹èŒƒå›´            | ç ç‚¹ä½æ•°  | å­—èŠ‚1     | å­—èŠ‚2    | å­—èŠ‚3    | å­—èŠ‚4     |
|:------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|
| U+0000 ~ U+007F    | 7        | 0xxxxxxx |
| U+0080 ~ U+07FF    | 11       | 110xxxxx | 10xxxxxx |
| U+0800 ~ U+FFFF    | 16       | 1110xxxx | 10xxxxxx | 10xxxxxx |
| U+10000 ~ U+10FFFF | 21       | 11110xxx | 10xxxxxx | 10xxxxxx | 10xxxxxx |

è¿™ä¸ªç¼–ç æ–¹æ³•çš„å¥½å¤„ä¹‹ä¸€æ˜¯ï¼Œç ç‚¹èŒƒå›´ U+0000 ~ U+007F ç¼–ç ä¸ºä¸€ä¸ªå­—èŠ‚ï¼Œä¸Ž ASCII ç¼–ç å…¼å®¹ã€‚è¿™èŒƒå›´çš„ Unicode ç ç‚¹ä¹Ÿæ˜¯å’Œ ASCII å­—ç¬¦ç›¸åŒçš„ã€‚å› æ­¤ï¼Œä¸€ä¸ª ASCII æ–‡æœ¬ä¹Ÿæ˜¯ä¸€ä¸ª UTF-8 æ–‡æœ¬ã€‚

æˆ‘ä»¬ä¸¾ä¸€ä¸ªä¾‹å­è§£æžå¤šå­—èŠ‚çš„æƒ…å†µï¼Œæ¬§å…ƒç¬¦å· `â‚¬` â†’ U+20ACï¼š

1. U+20AC åœ¨ U+0800 ~ U+FFFF çš„èŒƒå›´å†…ï¼Œåº”ç¼–ç æˆ 3 ä¸ªå­—èŠ‚ã€‚
2. U+20AC çš„äºŒè¿›ä½ä¸º 10000010101100
3. 3 ä¸ªå­—èŠ‚çš„æƒ…å†µæˆ‘ä»¬è¦ 16 ä½çš„ç ç‚¹ï¼Œæ‰€ä»¥åœ¨å‰é¢è¡¥ä¸¤ä¸ª 0ï¼Œæˆä¸º 0010000010101100
4. æŒ‰ä¸Šè¡¨æŠŠäºŒè¿›ä½åˆ†æˆ 3 ç»„ï¼š0010, 000010, 101100
5. åŠ ä¸Šæ¯ä¸ªå­—èŠ‚çš„å‰ç¼€ï¼š11100010, 10000010, 10101100
6. ç”¨åå…­è¿›ä½è¡¨ç¤ºå³ï¼š0xE2, 0x82, 0xAC

å¯¹äºŽè¿™ä¾‹å­çš„èŒƒå›´ï¼Œå¯¹åº”çš„ C ä»£ç æ˜¯è¿™æ ·çš„ï¼š

~~~c
if (u >= 0x0800 && u <= 0xFFFF) {
    OutputByte(0xE0 | ((u >> 12) & 0xFF)); /* 0xE0 = 11100000 */
    OutputByte(0x80 | ((u >>  6) & 0x3F)); /* 0x80 = 10000000 */
    OutputByte(0x80 | ( u        & 0x3F)); /* 0x3F = 00111111 */
}
~~~

UTF-8 çš„è§£ç ç¨å¤æ‚ä¸€ç‚¹ï¼Œä½†æˆ‘ä»¬çš„ JSON åº“ä¸ä¼šæ ¡éªŒ JSON æ–‡æœ¬æ˜¯å¦ç¬¦åˆ UTF-8ï¼Œæ‰€ä»¥è¿™é‡Œä¹Ÿä¸å±•å¼€äº†ã€‚

## 4. å®žçŽ° `\uXXXX` è§£æž

æˆ‘ä»¬åªéœ€è¦åœ¨å…¶å®ƒè½¬ä¹‰ç¬¦çš„å¤„ç†ä¸­åŠ å…¥å¯¹ `\uXXXX` çš„å¤„ç†ï¼š

~~~c
static int lept_parse_string(lept_context* c, lept_value* v) {
    unsigned u;
    /* ... */
    for (;;) {
        char ch = *p++;
        switch (ch) {
            /* ... */
            case '\\':
                switch (*p++) {
                    /* ... */
                    case 'u':
                        if (!(p = lept_parse_hex4(p, &u)))
                            STRING_ERROR(LEPT_PARSE_INVALID_UNICODE_HEX);
                        /* \TODO surrogate handling */
                        lept_encode_utf8(c, u);
                        break;
                    /* ... */
                }
            /* ... */
        }
    }
}
~~~

ä¸Šé¢ä»£ç çš„è¿‡ç¨‹å¾ˆç®€å•ï¼Œé‡åˆ° `\u` è½¬ä¹‰æ—¶ï¼Œè°ƒç”¨ `lept_parse_hex4()` è§£æž 4 ä½åå…­è¿›æ•°å­—ï¼Œå­˜å‚¨ä¸ºç ç‚¹ `u`ã€‚è¿™ä¸ªå‡½æ•°åœ¨æˆåŠŸæ—¶è¿”å›žè§£æžåŽçš„æ–‡æœ¬æŒ‡é’ˆï¼Œå¤±è´¥è¿”å›ž `NULL`ã€‚å¦‚æžœå¤±è´¥ï¼Œå°±è¿”å›ž `LEPT_PARSE_INVALID_UNICODE_HEX` é”™è¯¯ã€‚æœ€åŽï¼ŒæŠŠç ç‚¹ç¼–ç æˆ UTF-8ï¼Œå†™è¿›ç¼“å†²åŒºã€‚è¿™é‡Œæ²¡æœ‰å¤„ç†ä»£ç†å¯¹ï¼Œç•™ä½œç»ƒä¹ ã€‚

é¡ºå¸¦ä¸€æï¼Œæˆ‘ä¸º `lept_parse_string()` åšäº†ä¸ªç®€å•çš„é‡æž„ï¼ŒæŠŠè¿”å›žé”™è¯¯ç çš„å¤„ç†æŠ½å–ä¸ºå®ï¼š

~~~c
#define STRING_ERROR(ret) do { c->top = head; return ret; } while(0)
~~~

## 5. æ€»ç»“ä¸Žç»ƒä¹ 

æœ¬å•å…ƒä»‹ç»äº† Unicode çš„åŸºæœ¬çŸ¥è¯†ï¼ŒåŒå­¦åº”è¯¥äº†è§£åˆ°ä¸€äº›å¸¸ç”¨çš„ Unicode æœ¯è¯­ï¼Œå¦‚ç ç‚¹ã€ç¼–ç å•å…ƒã€UTF-8ã€ä»£ç†å¯¹ç­‰ã€‚è¿™æ¬¡çš„ç»ƒä¹ ä»£ç åªæœ‰ä¸ªç©ºå£³ï¼Œè¦ç”±åŒå­¦å¡«å……ã€‚å®ŒæˆåŽåº”è¯¥èƒ½é€šè¿‡æ‰€æœ‰å•å…ƒæµ‹è¯•ï¼Œå±Šæ—¶æˆ‘ä»¬çš„ JSON å­—ç¬¦ä¸²è§£æžå°±å®Œå…¨ç¬¦åˆæ ‡å‡†äº†ã€‚

1. å®žçŽ° `lept_parse_hex4()`ï¼Œä¸åˆæ³•çš„åå…­è¿›ä½æ•°è¿”å›ž `LEPT_PARSE_INVALID_UNICODE_HEX`ã€‚
2. æŒ‰ç¬¬ 3 èŠ‚è°ˆåˆ°çš„ UTF-8 ç¼–ç åŽŸç†ï¼Œå®žçŽ° `lept_encode_utf8()`ã€‚è¿™å‡½æ•°å‡è®¾ç ç‚¹åœ¨æ­£ç¡®èŒƒå›´ U+0000 ~ U+10FFFFï¼ˆç”¨æ–­è¨€æ£€æµ‹ï¼‰ã€‚
3. åŠ å…¥å¯¹ä»£ç†å¯¹çš„å¤„ç†ï¼Œä¸æ­£ç¡®çš„ä»£ç†å¯¹èŒƒå›´è¦è¿”å›ž `LEPT_PARSE_INVALID_UNICODE_SURROGATE` é”™è¯¯ã€‚

å¦‚æžœä½ é‡åˆ°é—®é¢˜ï¼Œæœ‰ä¸ç†è§£çš„åœ°æ–¹ï¼Œæˆ–æ˜¯æœ‰å»ºè®®ï¼Œéƒ½æ¬¢è¿Žåœ¨è¯„è®ºæˆ– [issue](https://github.com/miloyip/json-tutorial/issues) ä¸­æå‡ºï¼Œè®©æ‰€æœ‰äººä¸€èµ·è®¨è®ºã€‚





```c++

static int lept_parse_string(lept_context* c, lept_value* v) {
    size_t head = c->top, len;
    unsigned u;
    const char* p;
    EXPECT(c, '\"');
    p = c->json;
    for (;;) {
        char ch = *p++;
        switch (ch) {
            case '\"':
                len = c->top - head;
                lept_set_string(v, (const char*)lept_context_pop(c, len), len);
                c->json = p;
                return LEPT_PARSE_OK;
            case '\\':
                switch (*p++) {
                    case '\"': PUTC(c, '\"'); break;
                    case '\\': PUTC(c, '\\'); break;
                    case '/':  PUTC(c, '/' ); break;
                    case 'b':  PUTC(c, '\b'); break;
                    case 'f':  PUTC(c, '\f'); break;
                    case 'n':  PUTC(c, '\n'); break;
                    case 'r':  PUTC(c, '\r'); break;
                    case 't':  PUTC(c, '\t'); break;
                    case 'u':
                        if (!(p = lept_parse_hex4(p, &u)))
                            STRING_ERROR(LEPT_PARSE_INVALID_UNICODE_HEX);
                        /* \TODO surrogate handling */
                        if(*p == '\\' && *(p+1) == 'u')
                        {
                            p+=2;
                            /*æžœç¬¬ä¸€ä¸ªç ç‚¹æ˜¯ U+D800 è‡³ U+DBFFï¼ˆç®—ä¸€ä¸‹ç¡®å®žæ˜¯2^11ï¼‰ï¼Œ
                            æˆ‘ä»¬ä¾¿çŸ¥é“å®ƒçš„ä»£ç å¯¹çš„é«˜ä»£ç†é¡¹ï¼ˆhigh surrogateï¼‰ï¼Œ
                            ä¹‹åŽåº”è¯¥ä¼´éšä¸€ä¸ª U+DC00 è‡³ U+DFFF çš„ä½Žä»£ç†é¡¹ï¼ˆlow surrogateï¼‰ã€‚*/
                            if(u >= 0xD800 && u<= 0xDBFF)
                            {
                                unsigned u2 = 0;
                                unsigned i;
                                for ( i = 0; i < 4; i++)
                                {
                                    u2 += ((*p++)-'0') << (3-i)*4;
                                }
                                if(u2>=0xDC00 && u2 <= 0xDFFF)
                                {
                                    /*codepoint = 0x10000 + (H âˆ’ 0xD800) Ã— 
                                    0x400 + (L âˆ’ 0xDC00)*/
                                    u = 0x10000 + (u - 0xD800) * 0x400 + (u2-0xDC00);
                                }
                                else
                                STRING_ERROR(LEPT_PARSE_INVALID_UNICODE_SURROGATE);
                            }
                            else{
                                STRING_ERROR(LEPT_PARSE_INVALID_UNICODE_SURROGATE);
                            }
                        }
                        
                        lept_encode_utf8(c, u);
                        break;
                    default:
                        STRING_ERROR(LEPT_PARSE_INVALID_STRING_ESCAPE);
                }
                break;
            case '\0':
                STRING_ERROR(LEPT_PARSE_MISS_QUOTATION_MARK);
            default:
                if ((unsigned char)ch < 0x20)
                    STRING_ERROR(LEPT_PARSE_INVALID_STRING_CHAR);
                PUTC(c, ch);
        }
    }
}

```



```c

static const char* lept_parse_hex4(const char* p, unsigned* u) {
    /* \TODO */
    // è§£æžç ç‚¹ï¼ï¼
    // å°†på­—ç¬¦ä¸² ä¸­çš„jsonè¡¨ç¤ºçš„æ•°å­— è½¬åŒ–å…¥uä¸­
    char ch;
    for (size_t i = 0; i < 4; i++)
    {
        ch = *p++;
        if(ch>='0' && ch <= 'F')
        {
            // æ­£ç¡®çš„
            u += (ch-'0')<<(3-i)*4;
        }
        else
        {
            // é”™è¯¯çš„
            p = NULL;
            break;
        }
    }
    
    
    return p;
}

```



```
static void lept_encode_utf8(lept_context* c, unsigned u) {
    /*æŒ‰ç¬¬ 3 èŠ‚è°ˆåˆ°çš„ UTF-8 ç¼–ç åŽŸç†ï¼Œå®žçŽ° `lept_encode_utf8()`ã€‚
    è¿™å‡½æ•°å‡è®¾ç ç‚¹åœ¨æ­£ç¡®èŒƒå›´ U+0000 ~ U+10FFFFï¼ˆç”¨æ–­è¨€æ£€æµ‹ï¼‰ã€‚*/
    assert(u >= 0x00000 && u<=0x10FFFF);
    /* \TODO */
    /*
    |  U+0000 ~ U+007F   |  7   | 0xxxxxxx |          |          |          |
    | :----------------: | :--: | :------: | :------: | :------: | :------: |
    |  U+0080 ~ U+07FF   |  11  | 110xxxxx | 10xxxxxx |          |          |
    |  U+0800 ~ U+FFFF   |  16  | 1110xxxx | 10xxxxxx | 10xxxxxx |          |
    | U+10000 ~ U+10FFFF |  21  | 11110xxx | 10xxxxxx | 10xxxxxx | 10xxxxxx |
    */
    if(u >= 0x0000 && u <= 0x007F)
    {
        PUTC (c, OutputByte(u));
    }
    if(u >= 0x0080 && u <= 0x07FF)
    {
        PUTC(c, OutputByte(0xC0 | ((u >> 6)   & 0x1F)));
        PUTC(c, OutputByte(0x80 | (  u        & 0x3F)));
    }
    if (u >= 0x0800 && u <= 0xFFFF) {
        PUTC (c, OutputByte(0xE0 | ((u >> 12) & 0x0F))); /* 0xE0 = 11100000 */
        PUTC (c, OutputByte(0x80 | ((u >>  6) & 0x3F))); /* 0x80 = 10000000 */
        PUTC (c, OutputByte(0x80 | ( u        & 0x3F))); /* 0x3F = 00111111 */
    }
    if (u >= 0x10000 && u <= 0x10FFFF) {
        PUTC (c, OutputByte(0xF0 | ((u >> 18) & 0x07)));
        PUTC (c, OutputByte(0x80 | ((u >> 12) & 0x3F))); /* 0xE0 = 11100000 */
        PUTC (c, OutputByte(0x80 | ((u >>  6) & 0x3F))); /* 0x80 = 10000000 */
        PUTC (c, OutputByte(0x80 | ( u        & 0x3F))); /* 0x3F = 00111111 */
    }
}

char OutputByte(unsigned num)
{
    char ch;
    sprintf(&ch, "%x", num);
    return ch;
}

```

